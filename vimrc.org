#+property: header-args:vimrc :tangle .vimrc
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+BEGIN_SRC vimrc :exports none
  " Zyst

  " DO NOT EDIT THIS FILE DIRECTLY
  " This is a file generated from a literate programing source file located at
  " https://github.com/Zyst/dotfiles/blob/master/vimrc.org
  " You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+END_SRC

#+title: My Nvim/Vim config file
#+author: Erick Romero

This is my Emacs configuration file.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[file:.vimrc][.vimrc]] for the generated file.

* References

This is based on [[https://github.com/zzamboni][zzamboni's]] [[https://github.com/zzamboni/dot-emacs][dot-emacs]]. Huge props to them!

* Package management

First, I add a global variable which makes multi-platform stuff easier generally speaking. This variable can be found in the [[*System-specific configuration][System-specific configuration]] section.

#+BEGIN_SRC vimrc :noweb yes
  <<os-global>>
#+END_SRC

I use [[https://github.com/junegunn/vim-plug][junegunn/vim-plug]] to manage my vim dependencies. First we will try to autoinstall ~vim-plug~ if we don't have it installed already, and are not on Windows. On Windows we go to the repo, and follow the instructions there to install it by hand.

#+BEGIN_SRC vimrc
  if !(g:os == "Windows")
    if empty(glob('~/.vim/autoload/plug.vim'))
      silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    endif
  endif
#+END_SRC

We then call the start function for plug, setting different folders for vim, and neovim to install their dependencies. The ~plug#end()~ function is called at the end of this package management section.

We also add two reference blocks, =nvim plug= and =vim plug= to ass vim/nvim specific plugins.

#+BEGIN_SRC vimrc :noweb yes
  if has('nvim')
    call plug#begin('~/.config/nvim/plugged')
        <<nvim plug>>
  else
    call plug#begin('~/.vim/plugged')
        <<vim plug>>
  endif
#+END_SRC

Now we create a reference block for our plugins, where our Plugins will be inserted, but the import itself will be done in their relevant areas.

#+BEGIN_SRC vimrc :noweb yes
  <<plug>>
#+END_SRC

Finally, we close our ~plug#begin~ block.

#+BEGIN_SRC vimrc
  call plug#end()
#+END_SRC

* Keybindings

** Leader

Keep stealing stuff from https://github.com/wincent/wincent/blob/master/roles/dotfiles/files/.vim/plugin/mappings/leader.vim

- We map our leader key to be =Space=.

#+BEGIN_SRC vimrc
  let mapleader="\<Space>"
#+END_SRC

- We also set our local leader key.

#+BEGIN_SRC vimrc
  let maplocalleader="\\"
#+END_SRC

- We make =<Leader> <Leader>= open the last buffer.

#+BEGIN_SRC vimrc
  nnoremap <Leader><Leader> <C-^>
#+END_SRC

- Make =<Leader>= and =o= close all other buffers.

#+BEGIN_SRC vimrc
  nnoremap <Leader>o :only<CR>
#+END_SRC

- Make =<Leader>= and =w= write the current file.

#+BEGIN_SRC vimrc
  nnoremap <Leader>w :w<CR>
#+END_SRC

- Make =<Leader>= and =q= close the current buffer.

#+BEGIN_SRC vimrc
  nnoremap <Leader>q :q<CR>
#+END_SRC

** Normal mode

Steal stuff from https://github.com/wincent/wincent/blob/master/roles/dotfiles/files/.vim/plugin/mappings/normal.vim

- We disable arrow keys in Vim, this is the first setting I added, and I like to keep it around for fun.

#+BEGIN_SRC vimrc
  noremap <Up> <NOP>
  noremap <Down> <NOP>
  noremap <Left> <NOP>
  noremap <Right> <NOP>
#+END_SRC

- Make =tab= toggle folds at current position.

#+BEGIN_SRC vimrc
  nnoremap <Tab> za
#+END_SRC

- Move between panes in normal mode with =Ctrl= + =hjkl=.

#+BEGIN_SRC vimrc
  nnoremap <C-h> <C-w>h
  nnoremap <C-j> <C-w>j
  nnoremap <C-k> <C-w>k
  nnoremap <C-l> <C-w>l
#+END_SRC

- Pressing =<Esc> <Esc>= disables/hides the progressive search mode.

#+BEGIN_SRC vimrc
  nmap <Esc><Esc> :noh<CR><Esc>
#+END_SRC

- =<Leader> + e + v= opens our vimrc file in a new vertical split.

#+BEGIN_SRC vimrc
  nnoremap <Leader>ev :vsp ~/.vimrc<CR>
#+END_SRC

** Visual

- Move between panes in visual mode, same as other modes.

#+BEGIN_SRC vimrc
  xnoremap <C-h> <C-w>h
  xnoremap <C-j> <C-w>j
  xnoremap <C-k> <C-w>k
  xnoremap <C-l> <C-w>l
#+END_SRC

- J and K can be used to move selected lines in visual mode.

#+BEGIN_SRC vimrc
  vnoremap <S-j> :m '>+1<CR>gv=gv
  vnoremap <S-k> :m '<-2<CR>gv=gv
#+END_SRC

* Settings

- We disable module functionality [[https://www.techrepublic.com/blog/it-security/turn-off-modeline-support-in-vim/][for security]].

#+BEGIN_SRC vimrc
  set nomodeline
#+END_SRC

- Language type indentation [[https://vi.stackexchange.com/a/10125][this response]] describes each option in detail, but essentially it lets plugins handle indentation, and a few other things when possible.

#+BEGIN_SRC vimrc
  filetype indent plugin on
#+END_SRC

- Shares the system clipboard.

#+BEGIN_SRC vimrc
  set clipboard+=unnamedplus
#+END_SRC

- We display line numbers.

#+BEGIN_SRC vimrc
  set number
#+END_SRC

- We make it so that when we leave a buffer, that buffer uses normal line numbers, but if we are on the buffer we use relative line numbers.

#+BEGIN_SRC vimrc
  augroup numbertoggle
    autocmd!
    autocmd BufEnter,FocusGained,WinEnter * if &nu | set rnu   | endif
    autocmd BufLeave,FocusLost,WinLeave   * if &nu | set nornu | endif
  augroup END
#+END_SRC

- We =set hidden= which does some operations around renames, and others. Also lets us hide buffers with unsaved changes without being promted.

#+BEGIN_SRC vimrc
  set hidden
#+END_SRC

- Makes it so that =.vimrc= is autoreloaded when we write changes to it.

#+BEGIN_SRC vimrc
  augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
  augroup END
#+END_SRC

- Allows backspace to work 'normally'.

#+BEGIN_SRC vimrc
  set backspace=indent,eol,start
#+END_SRC

- Enables folding for files, sets the indentation method to =indent= which folds based on indentation levels, and sets the fold level we start out with files to =10=, which starts out files unfolded up to the =10='th level of indentation.

#+BEGIN_SRC vimrc
  set foldenable
  set foldmethod=indent
  set foldlevelstart=10
#+END_SRC

- We set the fold level to =1=, which as [[https://www.youtube.com/watch?v=oqYQ7IeDs0E][Wincent's video on folding]] mentions, is good for getting into the habit of actually using the fold feature. /Disabled for now, I want to get into actually using the editor adequately before I attempt to min-max my feature usage/.

#+BEGIN_SRC vimrc
  " set foldlevelstart=1
#+END_SRC

- Copies the indentation from the previous line when creating a new line.

#+BEGIN_SRC vimrc
  set autoindent
#+END_SRC

- Smart indent automatically adds one extra level of indentation in some scenarios.

#+BEGIN_SRC vimrc
  set smartindent
#+END_SRC

- Sets encoding to UTF-8, can help avoid a ton of issues. This applies to the buffer, and to the written files.

#+BEGIN_SRC vimrc
  scriptencoding utf-8
  set encoding=utf-8
  set fileencoding=utf-8
#+END_SRC

- Highlight the current line we are on.

#+BEGIN_SRC vimrc
  set cursorline
#+END_SRC

- Make vim use spaces instead of tabs.

#+BEGIN_SRC vimrc
set expandtab
#+END_SRC

- Handle file history, and make sure the files are written to a separate folder.

#+BEGIN_SRC vimrc
  set undofile
  set undodir=~/.vim/undo_files//
  set directory=~/.vim/swap_files//
#+END_SRC

- We make vim always display our status line.

#+BEGIN_SRC vimrc
  set laststatus=2
#+END_SRC

- We set lazyredraw so we don't show screen changes when playing macros, or stuff like that.

#+BEGIN_SRC vimrc
  set lazyredraw
#+END_SRC

- We make long lines wrap into others based on the =breakat= setting, and we change the character we use to display line breaks. the character we use is: "DOWNWARDS ARROW WITH TIP RIGHTWARDS (U+21B3, UTF-8: E2 86 B3)"

#+BEGIN_SRC vimrc
  set linebreak
  let &showbreak='â†³ '
#+END_SRC

- We set our scrollout, which allows us to scroll a specified number of lines before we reach the "edge" of our screen.

#+BEGIN_SRC vimrc
  set scrolloff=1
#+END_SRC

- We add a =tabstop=, which specifies how many characters we should insert when when press tab. Similarly, a =softtabstop= specifies how many columns to insert when we press tab.

#+BEGIN_SRC vimrc
  set tabstop=2
  set softtabstop=2
#+END_SRC

- We add a =shiftwidth=, which inserts a number of spaces per tab, and commands like =<< >>=. We also set =shiftround= which itself lets us indent by a multiple of =shiftwidth= everytime.

#+BEGIN_SRC vimrc
  set shiftround
  set shiftwidth=2
#+END_SRC

- We make it so that when we insert a split, it opens below the current window, or to the right of the current window. Rather than up/left.

#+BEGIN_SRC vimrc
  set splitbelow
  set splitright
#+END_SRC

- Visually wraps lines that go past a limit, we also automatically set the corresponding wrap setting to 80 characters.

#+BEGIN_SRC vimrc
  set wrap
  set textwidth=80
#+END_SRC

- Highlights matching items like ({[]}).

#+BEGIN_SRC vimrc
  set showmatch
#+END_SRC

- Set search to search as you type characters, we also ingore case while searching.

#+BEGIN_SRC vimrc
  set incsearch
#+END_SRC

- For search, we make it so that when =ignorecase= and =smartcase= are both on, if a pattern contains an uppercase letter, it is case sensitive, otherwise, it is not. For example, =/The= would find only =The=, while =/the= would find =the= or =The= etc.

#+BEGIN_SRC vimrc
  set ignorecase
  set smartcase
#+END_SRC

- Make the cursor blink on errors, rather than beeping.

#+BEGIN_SRC vimrc
  set visualbell
#+END_SRC

- Sets ttyfast, which indicates a fast terminal connection, so it sends more characters to the screen for rendering.

#+BEGIN_SRC vimrc
  set ttyfast
#+END_SRC

- Sets =hlsearch=, which makes the characters we search shiny.

#+BEGIN_SRC vimrc
  set hlsearch
#+END_SRC

- We disable backup files generally speaking, some LanguageServers have issues with them.

#+BEGIN_SRC vimrc
  set nobackup
  set nowritebackup
#+END_SRC

- We make it so that =signcolumns= are always enabled so that some of our plugins which modify the sign column don't constantly move that around.

#+BEGIN_SRC vimrc
  set signcolumn=yes
#+END_SRC

* System-specific configuration

Some settings are OS-specific, and this is where we set them.

First, we add a variable ~g:os~ which will hold our OS information, for now, our main concern is focused around the following three variable possible values: ~Windows~, ~Linux~, and ~Darwin~ (OS X).

We also want an additional entry for "Unix" systems, in our case, Linux, and OS X can share a lot of configuration, so we will create an extra entry for that.

#+begin_src vimrc :tangle no :noweb-ref os-global
  if !exists("g:os")
      if has("win64") || has("win32") || has("win16")
          let g:os = "Windows"
      else
          let g:os = substitute(system('uname'), '\n', '', '')
      endif
  endif
#+end_src

Then, we add our OS-specific configuration from the sections below:

#+BEGIN_SRC vimrc :noweb no-export
  if g:os == "Linux"
      <<Linux settings>>
  endif

  if g:os == "Windows"
      <<Windows settings>>
  endif

  if g:os == "Darwin"
      <<Mac settings>>
  endif

  if (g:os == "Linux") || (g:os == "Darwin")
      <<Unix settings>>
  endif
#+END_SRC

** Linux
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Linux settings
:END:

There are no Linux-specific settings for now.

** Windows
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Windows settings
:END:

There are no Windows-specific settings for now.

** Mac
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Mac settings
:END:

There are no Mac-specific settings for now.

** Unix
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Unix settings
:END:

There are no Unix-specific settings for now.

* Org mode

We will setup org mode later, for now, just get shit running. Reference [[file:init.org][init.org]] for reference on how to structure org mode.

* Appearance, buffer/file management and theming

Here we take care of all the visual, and UX settings.

We enable =termguicolors=, which is necessary to use GUI colors inside terminals.

#+BEGIN_SRC vimrc
  if (has("termguicolors"))
    set termguicolors
  endif
#+END_SRC

We also want to set ~syntax~ to ~on~, which makes the editor allow syntax highlighting.

#+BEGIN_SRC vimrc
  syntax on
#+END_SRC

** Theme

Our theme is the bespoke [[https://github.com/Zyst/egoist-one.vim][Zyst/egoist-one.vim]], which is in turn based on [[https://github.com/joshdick/onedark.vim][joshdick/onedark.vim]]. It customizes some elements to my liking.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'Zyst/egoist-one.vim'
#+END_SRC

We proceed to assign our ~colorscheme~ as ~onedark~.

#+BEGIN_SRC vimrc
  colorscheme onedark
#+END_SRC

Echo highlight group under cursor. This can be called using =:call HighlightEcho()= in our Vim commands. I mainly use this to find out the name of highlight groups I want to modify in my own theme.

#+BEGIN_SRC vimrc
  function g:HighlightEcho ()
    " Echo under mouse
    echom synIDattr(synID(line("."),col("."),1),"name")

    " Echo full group
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
  endfunction
#+END_SRC

Finally, we set ~g:onedark_terminal_italics~ to ~1~ which enables some of the theme's italics functionality.

#+BEGIN_SRC vimrc
  let g:onedark_terminal_italics=1
#+END_SRC

** CSS colors

Adding [[https://github.com/ap/vim-css-color][ap/vim-css-color]] allows us to have some variable color/background highlighting in our CSS files.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'ap/vim-css-color'
#+END_SRC

** Airline

We are going to add [[https://github.com/vim-airline/vim-airline][vim-airline/vim-airline]] which adds a nice status bar for us.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'vim-airline/vim-airline'
#+END_SRC

** Version control management

We add a few plugins to handle version control systems.

We use [[https://github.com/tpope/vim-fugitive][tpope/vim-fugitive]] for git integration, mainly around line changes.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'tpope/vim-fugitive'
#+END_SRC

[[https://github.com/mhinz/vim-signify][mhinz/vim-signify]] displays a git gutter with changes, or added lines.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'mhinz/vim-signify'
#+END_SRC

** Fuzzy finder

We use two fuzzy finders, depending on the operating system, If we are on Unix systems, then we use [[https://github.com/wincent/command-t][wincent/command-t]], otherwise (Windows, in my case) we use [[https://github.com/ctrlpvim/ctrlp.vim][ctrlpvim/ctrlp.vim]].

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  if !(g:os == "Windows")
    Plug 'wincent/command-t', {
          \   'do': 'cd ruby/command-t/ext/command-t && ruby extconf.rb && make'
          \ }
  else
    Plug 'ctrlpvim/ctrlp.vim'
  endif
#+END_SRC

*** Command-T configuration
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Unix settings
:END:

- These are the default hotkeys:

The following mappings are active when the prompt has focus:

#+BEGIN_SRC text
  <BS>        delete the character to the left of the cursor
  <Del>       delete the character at the cursor
  <Left>      move the cursor one character to the left
  <C-h>       move the cursor one character to the left
  <Right>     move the cursor one character to the right
  <C-l>       move the cursor one character to the right
  <C-a>       move the cursor to the start (left)
  <C-e>       move the cursor to the end (right)
  <C-u>       clear the contents of the prompt
  <Tab>       change focus to the file listing
#+END_SRC

The following mappings are active when the file listing has focus:

#+BEGIN_SRC text
  <Tab>       change focus to the prompt
#+END_SRC

The following mappings are active when either the prompt or the file listing
has focus:

#+BEGIN_SRC text
  <CR>        open the selected file
  <C-CR>      open the selected file in a new split window
  <C-s>       open the selected file in a new split window
  <C-v>       open the selected file in a new vertical split window
  <C-t>       open the selected file in a new tab
  <C-d>       delete the selected buffer
  <C-j>       select next file in the file listing
  <C-n>       select next file in the file listing
  <Down>      select next file in the file listing
  <C-k>       select previous file in the file listing
  <C-p>       select previous file in the file listing
  <Up>        select previous file in the file listing
  <C-f>       flush the cache (see |:CommandTFlush| for details)
  <C-q>       place the current matches in the quickfix window
  <C-c>       cancel (dismisses file listing)
#+END_SRC

The following is also available on terminals which support it:

#+BEGIN_SRC text
  <Esc>       cancel (dismisses file listing)
#+END_SRC

- We remap =Leader= + =b= to use =CommandTMRU= instead of =CommandTBuffer=, which shows files in the most recently used order, rather than the default.

#+BEGIN_SRC vimrc
  nnoremap <silent> <leader>b :CommandTMRU<CR>
#+END_SRC

- We make the set of keys that close the search buffer different, =Escape= and =Ctrl= + =c= handle it.

#+BEGIN_SRC vimrc
  let g:CommandTCancelMap=['<ESC>', '<C-c>']
#+END_SRC

- Switch encoding so that it is =UTF-8= by default.

#+BEGIN_SRC vimrc
  let g:CommandTEncoding='UTF-8'
#+END_SRC

- We make the file scanner ~watchman~. which falls back to =find= by default. /For now, lets use the default unless we need watchman/.

#+BEGIN_SRC vimrc
  " let g:CommandTFileScanner='watchman'
#+END_SRC

- We add =wildignore= settings which allow us to ignore certain patterns automatically with CommandT

#+BEGIN_SRC vimrc
  let g:CommandTWildIgnore=&wildignore
  let g:CommandTWildIgnore.=',*/.git'
  let g:CommandTWildIgnore.=',*/.hg'
  let g:CommandTWildIgnore.=',*/bower_components'
  let g:CommandTWildIgnore.=',*/node_modules'
  let g:CommandTWildIgnore.=',*/tmp'
  let g:CommandTWildIgnore.=',*/vendor'
  let g:CommandTWildIgnore.=',*/dist'
  let g:CommandTWildIgnore.=',*/lcov-report'
  let g:CommandTWildIgnore.=',*/public/static'
  let g:CommandTWildIgnore.=',*/test-reports'
  let g:CommandTWildIgnore.=',*/__snapshots__'
  let g:CommandTWildIgnore.=',*/helm'
  let g:CommandTWildIgnore.=',*/pipeline'
  let g:CommandTWildIgnore.=',*/build'
  let g:CommandTWildIgnore.=',*/coverage'
#+END_SRC

*** ctrlp.vim configuration
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Windows settings
:END:

Allow ctrlp ignore the files inside of ~.gitignore~ files.

#+BEGIN_SRC vimrc
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
#+END_SRC

** Nerdtree

[[https://github.com/scrooloose/nerdtree][scrooloose/nerdtree]] is added for visual project exploration.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'scrooloose/nerdtree'
#+END_SRC

We make <Leader> and n open up nerdtree.

#+BEGIN_SRC vimrc
  nmap <Leader>n :NERDTreeFind<CR>
#+END_SRC

** Editor config

We add [[https://editorconfig.org/][editorconfig]] to Vim, which allows us to edit different projects with disparate configurations with ease.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'editorconfig/editorconfig-vim'
#+END_SRC

** Projectionist
I want to use [[https://github.com/tpope/vim-projectionist][vim-projectionst]], mainly for switching between alternate files.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'tpope/vim-projectionist'
#+END_SRC

*** Alternate file configuration

We configure the base global variable, with C support since it's fairly straight-forward to add.

#+BEGIN_SRC vimrc
  let g:projectionist_heuristics = {
  \   '*': {
  \     '*.c': {
  \       'alternate': '{}.h',
  \       'type': 'source'
  \     },
  \     '*.h': {
  \       'alternate': '{}.c',
  \       'type': 'header'
  \     },
  \
  \   }
  \ }
#+END_SRC

We then batch update JS/JSX/TS/TSX bindings using a super cool utility function by [[https://github.com/wincent][wincent]].

#+BEGIN_SRC vimrc
  " Helper function for batch-updating the g:projectionist_heuristics variable.
  function! s:project(...)
    for [l:pattern, l:projection] in a:000
      let g:projectionist_heuristics['*'][l:pattern] = l:projection
    endfor
  endfunction

  " Set up projections for JS variants.
  for s:extension in ['.js', '.jsx', '.ts', '.tsx']
    call s:project(
          \ ['*' . s:extension, {
          \   'alternate': [
          \     '{dirname}/{basename}.test' . s:extension,
          \     '{dirname}/__tests__/{basename}-test' . s:extension,
          \     '{dirname}/__tests__/{basename}.test' . s:extension,
          \     '{dirname}/__tests__/{basename}.test.js',
          \   ],
          \   'type': 'source'
          \ }],
          \ ['*.test' . s:extension, {
          \   'alternate': '{basename}' . s:extension,
          \   'type': 'test',
          \ }],
          \ ['**/__tests__/*-test' . s:extension, {
          \   'alternate': '{dirname}/{basename}' . s:extension,
          \   'type': 'test'
          \ }],
          \ ['**/__tests__/*.test' . s:extension, {
          \   'alternate': [
          \     '{dirname}/{basename}' . s:extension,
          \     '{dirname}/{basename}.tsx',
          \     '{dirname}/{basename}.ts',
          \     '{dirname}/{basename}.js',
          \     '{dirname}/{basename}.jsx',
          \    ],
          \   'type': 'test'
          \ }])
  endfor
#+END_SRC

Finally, we map =<Leader>= and =a= to go to our alternate file.

#+BEGIN_SRC vimrc
  nnoremap <Leader>a :A<CR>
#+END_SRC

* Coding

** General settings and modules

*** Deoplete

First, we add [[https://github.com/Shougo/deoplete.nvim][Shougo/deoplete.nvim]]. There's two blocks, of which one corresponds to the nvim configuration required to add Deoplete, and the other, for vim. Since vim needs a couple of "bridge" elements.

#+BEGIN_SRC vimrc :tangle no :noweb-ref nvim plug
  Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
  Plug 'Shougo/deoplete-lsp'
#+END_SRC

#+BEGIN_SRC vimrc :tangle no :noweb-ref vim plug
  Plug 'Shougo/deoplete.nvim'
  Plug 'roxma/nvim-yarp'
  Plug 'roxma/vim-hug-neovim-rpc'
#+END_SRC

We then make it so that deoplete starts along with our editor.

#+BEGIN_SRC vimrc
  let g:deoplete#enable_at_startup = 1
#+END_SRC

Tab should make deoplete select items in insert mode.

#+BEGIN_SRC vimrc
  inoremap <expr> <TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
#+END_SRC

*** Language Server Protocol

We add our LSP implementation of choice, we're using the Neovim 0.5 LSP default configuration.

#+BEGIN_SRC vimrc :tangle no :noweb-ref nvim plug
  Plug 'neovim/nvim-lsp'
#+END_SRC

We begin a lua block for our configurations.

#+BEGIN_SRC vimrc :noweb no-export
  lua << END
    <<Lua LSP>>
  END
#+END_SRC

We also want to add a function for running our LSP installs.

#+BEGIN_SRC vimrc :noweb no-export
  function g:InstallLangServProtocols ()
    " Here we want to consider whether to automate calls like :LspInstall elmls
  endfunction
#+END_SRC

Now we add some hotkeys we'd like.

#+BEGIN_SRC vimrc
  nnoremap <silent>gd <cmd>lua vim.lsp.buf.declaration()<CR>
#+END_SRC

**** Clojure

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.clojure_lsp.setup{}
#+END_SRC

**** CSS

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.cssls.setup{}
#+END_SRC

**** Elm

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.elmls.setup{}
#+END_SRC

**** HTML

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.html.setup{}
#+END_SRC

**** JavaScript

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.tsserver.setup{}
#+END_SRC

**** Nix

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.rnix.setup{}
#+END_SRC

**** Python

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.pyls.setup{}
#+END_SRC

**** YAML

#+BEGIN_SRC vimrc :tangle no :noweb-ref Lua LSP
  require'nvim_lsp'.yamlls.setup{}
#+END_SRC

*** Linter

We use [[https://github.com/w0rp/ale][w0rp/ale]] for linting, and more. It integrates very nicely with LSP as well.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'w0rp/ale'
#+END_SRC

We add configuration for our fixers. First, we want every filetype to remove trailing lines, and whitespace on save. Another filetype we want to cover is JavaScript, where we run both =prettier=, and =eslint --fix= in that order.

#+BEGIN_SRC vimrc
  let g:ale_fixers = {
  \   '*': ['remove_trailing_lines', 'trim_whitespace'],
  \   'javascript': ['prettier', 'eslint'],
  \   'typescript': ['prettier', 'eslint'],
  \   'typescriptreact': ['prettier', 'eslint'],
  \   'css': ['prettier'],
  \   'scss': ['prettier'],
  \   'html': ['prettier'],
  \   'json': ['prettier'],
  \}
#+END_SRC

We make our formatting tool run on <Leader> and f.

#+BEGIN_SRC vimrc
  nmap <Leader>f <Plug>(ale_fix)
#+END_SRC

*** Autoclosing

[[https://github.com/jiangmiao/auto-pairs][jiangmiao/auto-pairs]] closes tags for us, like ({[]})

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'jiangmiao/auto-pairs'
#+END_SRC

*** Emmet

Using [[https://github.com/mattn/emmet-vim][mattn/emmet-vim]] we can use shorthands to create HTML/JSX structures. Ie: =table.our-table= -> ~<table class="our-table"></table>~

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'mattn/emmet-vim'
#+END_SRC

We remap the o

#+BEGIN_SRC vimrc
  let g:user_emmet_expandabbr_key = '<C-e>'
#+END_SRC

** Programming languages

*** Polyglot

Our main language handler is [[https://github.com/sheerun/vim-polyglot][sheerun/vim-polyglot]] which helps us program in a [[https://github.com/sheerun/vim-polyglot#language-packs][variety of languages]] with minimal performance impact, since plugins are loaded on-demand. I'm giving this a try, rather than using individual packages.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'sheerun/vim-polyglot'
#+END_SRC

*** Elvish

[[https://github.com/dmix/elvish.vim][dmix/elvish.vim]] adds limited support for the [[https://github.com/elves/elvish][elvish shell]], essentially limited to syntax highlighting.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'dmix/elvish.vim', { 'on_ft': ['elvish']}
#+END_SRC

* Other tools

** Vim commentary

[[https://github.com/tpope/vim-commentary][tpope/vim-commentary]] is a plugin that allows us to comment out code in a very natural way with a motion mainly mapped to ~gc~.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'tpope/vim-commentary'
#+END_SRC

** Vim surround

[[https://github.com/tpope/vim-surround][tpope/vim-surround]] is all about "surroundings": parentheses, brackets, quotes, XML tags, and more. The plugin provides mappings to easily delete, change and add such surroundings in pairs.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'tpope/vim-surround'
#+END_SRC

** Vim/Tmux interplay

We use [[https://github.com/christoomey/vim-tmux-navigator][christoomey/vim-tmux-navigator]] to allow us to switch between Vim, and Tmux panes effortlessly, using ~Ctrl + hjkl~.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'christoomey/vim-tmux-navigator'
#+END_SRC

* General text editing

In addition to coding, I configure some modes that can be used for text editing.

No configuration for now, maybe spellchecking?
