#+property: header-args:vimrc :tangle .vimrc
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+BEGIN_SRC vimrc :exports none
  " Zyst

  " DO NOT EDIT THIS FILE DIRECTLY
  " This is a file generated from a literate programing source file located at
  " https://github.com/Zyst/dotfiles/blob/master/vimrc.org
  " You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+END_SRC

#+title: My Nvim/Vim config file
#+author: Erick Romero

This is my Emacs configuration file.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[file:.vimrc][.vimrc]] for the generated file.

* References

This is based on [[https://github.com/zzamboni][zzamboni's]] [[https://github.com/zzamboni/dot-emacs][dot-emacs]]. Huge props to them!

* Package management

First, I add a global variable which makes multi-platform stuff easier generally speaking. This variable can be found in the [[*System-specific configuration][System-specific configuration]] section.

#+BEGIN_SRC vimrc :noweb yes
  <<os-global>>
#+END_SRC

I use [[https://github.com/junegunn/vim-plug][junegunn/vim-plug]] to manage my vim dependencies. First we will try to autoinstall ~vim-plug~ if we don't have it installed already, and are not on Windows. On Windows we go to the repo, and follow the instructions there to install it by hand.

#+BEGIN_SRC vimrc
  if !(g:os == "Windows")
    if empty(glob('~/.vim/autoload/plug.vim'))
      silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    endif
  endif
#+END_SRC

We then call the start function for plug, setting different folders for vim, and neovim to install their dependencies. The ~plug#end()~ function is called at the end of this package management section.

#+BEGIN_SRC vimrc
if has('nvim')
  call plug#begin('~/.config/nvim/plugged')
else
  call plug#begin('~/.vim/plugged')
endif
#+END_SRC

Now we create a reference block for our plugins, where our Plugins will be inserted, but the import itself will be done in their relevant areas.

#+BEGIN_SRC vimrc :noweb yes
  <<plug>>
#+END_SRC

Finally, we close our ~plug#begin~ block.

#+BEGIN_SRC vimrc
  call plug#end()
#+END_SRC

* Settings

** Miscellaneous settings

hold

* System-specific configuration

Some settings are OS-specific, and this is where we set them.

First, we add a variable ~g:os~ which will hold our OS information, for now, our main concern is focused around the following three variable possible values: ~Windows~, ~Linux~, and ~Darwin~ (OS X).

#+begin_src vimrc :tangle no :noweb-ref os-global
  if !exists("g:os")
      if has("win64") || has("win32") || has("win16")
          let g:os = "Windows"
      else
          let g:os = substitute(system('uname'), '\n', '', '')
      endif
  endif
#+end_src

Then, we add our OS-specific configuration from the sections below:

#+BEGIN_SRC vimrc :noweb no-export
  if g:os == "Darwin"
      <<Mac settings>>
  endif

  if g:os == "Linux"
      <<Linux settings>>
  endif

  if g:os == "Windows"
      <<Windows settings>>
  endif
#+END_SRC

** Mac
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Mac settings
:END:

There are no Mac-specific settings for now.

#+BEGIN_SRC vimrc
  nnoremap <leader>t :term <CR>
#+END_SRC

Also lol

#+BEGIN_SRC vimrc
  echo "mac lol"
#+END_SRC

** Linux
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Linux settings
:END:

There are no Linux-specific settings for now.

#+BEGIN_SRC vimrc
  nnoremap <leader>t :term <CR>
#+END_SRC

Also lol

#+BEGIN_SRC vimrc
  echo "linux"
#+END_SRC

** Windows
:PROPERTIES:
:header-args:vimrc: :tangle no :noweb-ref Windows settings
:END:

There are no Windows-specific settings for now.

#+BEGIN_SRC vimrc
  nnoremap <leader>t :term "C:\Program Files\Git\bin\bash.exe" <CR>
#+END_SRC

Also lol

#+BEGIN_SRC vimrc
  echo "windows"
#+END_SRC

* Org mode

I have started using [[http://orgmode.org/][org-mode]] to writing, blogging, coding, presentations and more, thanks to the hearty recommendations and information from [[http://www.cmdln.org/][Nick]] and many others. I am duly impressed. I have been a fan of the idea of [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] for many years, and I have tried other tools before (most notably [[https://www.cs.tufts.edu/~nr/noweb/][noweb]], which I used during grad school for many of my homeworks and projects), but org-mode is the first tool I have encountered which seems to make it practical. Here are some of the resources I have found useful in learning it:

- Howard Abrams' [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]], which got me jumpstarted into writing code documented with org-mode.
- Nick Anderson's [[https://github.com/nickanderson/Level-up-your-notes-with-Org][Level up your notes with Org]], which contains many useful tips and configuration tricks.
- Sacha Chua's [[http://sachachua.com/blog/2014/01/tips-learning-org-mode-emacs/][Some tips for learning Org Mode for Emacs]], her [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]] and many of her [[http://sachachua.com/blog/category/emacs/][other articles]].
- Rainer KÃ¶nig's [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][OrgMode Tutorial]] video series.

This is the newest and most-in-flux section of my Emacs config, since I'm still learning org-mode myself.

I use =use-package= to load the =org= package, and put its configuration inside the corresponding sections for keybindings (=:bind=), custom variables (=:custom=), custom faces (=:custom-face=), hooks (=:hook=) and general configuration code (=:config=), respectively. The contents of each section is populated with the corresponding snippets that follow. You see here the complete =use-package= declaration for completeness, but see the sections below for the details on where each snippet comes from, and some other configuration code that ends up outside this declaration.

#+begin_src emacs-lisp :noweb yes
  (use-package org
    :bind
      <<org-mode-keybindings>>
    :custom
      <<org-mode-custom-vars>>
    :custom-face
      <<org-mode-faces>>
    :hook
      <<org-mode-hooks>>
    :config
      <<org-mode-config>>)
#+end_src

** General org-mode configuration

Automatically log done times in todo items.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-log-done t)
#+end_src

Keep the indentation well structured by setting =org-startup-indented= to =t=. This is a must have. Makes it feel less like editing a big text file and more like a purpose built editor for org-mode that forces the indentation. Thanks [[https://github.com/nickanderson/Level-up-your-notes-with-Org/blob/master/Level-up-your-notes-with-Org.org#automatic-visual-indention][Nick]] for the tip!

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-startup-indented t)
#+end_src

By default, =org-indent= produces an indicator ="Ind"= in the modeline. We use diminish to hide it.

#+begin_src emacs-lisp
  (use-package org-indent
    :ensure nil
    :diminish)
#+end_src

** Miscellaneous org functions

** Keybindings

** Various exporters

One of the big strengths of org-mode is the ability to export a document in many different formats. Here I load some of the exporters I have found useful.

- Markdown

  #+begin_src emacs-lisp
    (use-package ox-md
      :ensure nil
      :defer 3
      :after org)
  #+end_src

- [[https://help.github.com/categories/writing-on-github/][GitHub Flavored Markdown]]

  #+begin_src emacs-lisp
    (use-package ox-gfm
      :defer 3
      :after org)
  #+end_src

- [[https://github.com/stig/ox-jira.el][Jira markup]]. I also load =org-jira=, which provides a full interface to Jira through org-mode.

  #+begin_src emacs-lisp
    (use-package ox-jira
      :defer 3
      :after org)
    (use-package org-jira
      :defer 3
      :after org
      :custom
      (jiralib-url "https://jira.swisscom.com"))
  #+end_src

- Confluence markup.

  #+begin_src emacs-lisp
    (use-package ox-confluence
      :defer 3
      :ensure nil
      :after org)
  #+end_src

** Literate programming using org-babel

Org-mode is the first literate programming tool that seems practical and useful, since it's easy to edit, execute and document code from within the same tool (Emacs) using all of its existing capabilities (i.e. each code block can be edited in its native Emacs mode, taking full advantage of indentation, completion, etc.)

Define =shell-script-mode= as an alias for =console-mode=, so that =console= src blocks can be edited and are fontified correctly.

#+begin_src emacs-lisp
  (defalias 'console-mode 'shell-script-mode)
#+end_src

We configure the languages for which to load org-babel support.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python    . t)
     (shell     . t)
     (calc      . t)))
#+end_src

This is potentially dangerous: it suppresses the query before executing code from within org-mode. I use it because I am very careful and only press =C-c C-c= on blocks I absolutely understand.

Disabled while I know if I'm actually very careful, lmao.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  ;; (org-confirm-babel-evaluate nil)
#+end_src

This makes it so that code within =src= blocks is fontified according to their corresponding Emacs mode, making the file much more readable.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-src-fontify-natively t)
#+end_src

In principle this makes it so that indentation in =src= blocks works as in their native mode, but in my experience it does not always work reliably. For full proper indentation, always edit the code in a native buffer by pressing =C-c '=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-src-tab-acts-natively t)
#+end_src

Automatically show inline images, useful when executing code that produces them, such as PlantUML or Graphviz.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-babel-after-execute . org-redisplay-inline-images)
#+end_src

This little snippet has revolutionized my literate programming workflow. It automatically runs =org-babel-tangle= upon saving any org-mode buffer, which means the resulting files will be automatically kept up to date.

Temporarily disabled while I do my initial configuration, this is causing me a bit more pain that I'd like to admit.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-mode . (lambda () (add-hook 'after-save-hook 'org-babel-tangle
                                   'run-at-end 'only-in-org-mode)))
#+end_src

I add hooks to measure and report how long the tangling took.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-babel-pre-tangle  . (lambda ()
                             (setq zz/pre-tangle-time (current-time))))
  (org-babel-post-tangle . (lambda ()
                             (message "org-babel-tangle took %s"
                                             (format "%.2f seconds"
                                                     (float-time (time-since zz/pre-tangle-time))))))
#+end_src

** Beautifying org-mode

These settings make org-mode much more readable by using different fonts for headings, hiding some of the markup, etc. This was taken originally from Howard Abrams' [[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html][Org as a Word Processor]], and subsequently tweaked and broken up in the different parts of the =use-package= declaration by me.

First, we set =org-hid-emphasis-markers= so that the markup indicators are not shown.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-hide-emphasis-markers t)
#+end_src

We add an entry to the org-mode font-lock table so that list markers are shown with a middle dot instead of the original character.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â¢"))))))
#+end_src

We use the =org-bullets= package to display the titles with nice unicode bullets instead of the text ones.

#+begin_src emacs-lisp
  (use-package org-bullets
    :disabled
    :after org
    :hook
    (org-mode . (lambda () (org-bullets-mode 1))))
#+end_src

We choose a nice font for the document title and the section headings. The first one found in the system from the list below is used, and the same font is used for the different levels, in varying sizes.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (let* ((variable-tuple
          (cond ((x-list-fonts   "Roboto")          '(:font   "Roboto"))
                ((x-list-fonts   "Source Sans Pro") '(:font   "Source Sans Pro"))
                ((x-list-fonts   "Lucida Grande")   '(:font   "Lucida Grande"))
                ((x-list-fonts   "Verdana")         '(:font   "Verdana"))
                ((x-family-fonts "Sans Serif")      '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color (face-foreground 'default nil 'default))
         (headline       `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces
     'user
     `(org-level-8        ((t (,@headline ,@variable-tuple))))
     `(org-level-7        ((t (,@headline ,@variable-tuple))))
     `(org-level-6        ((t (,@headline ,@variable-tuple))))
     `(org-level-5        ((t (,@headline ,@variable-tuple))))
     `(org-level-4        ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3        ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2        ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1        ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

I use proportional fonts in org-mode for the text, while keeping fixed-width fonts for blocks, so that source code, tables, etc. are shown correctly. These settings include:

- Setting up the =variable-pitch= face to the proportional font I like to use. I myself use [[https://fonts.google.com/specimen/Roboto][Roboto]]. I'm leaving in the entries from the author who enjoys, [[https://en.wikipedia.org/wiki/Source_Sans_Pro][Source Sans Pro]] and [[https://en.wikipedia.org/wiki/Avenir_(typeface)][Avenir Next]].
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (variable-pitch ((t (:family "Roboto" :height 180 :weight light))))
    ;; (variable-pitch ((t (:family "Source Sans Pro" :height 180 :weight light))))
  #+end_src

- Setting up the =fixed-pitch= face to be the same as my usual =default= face.
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (fixed-pitch ((t (:family "Operator Mono SSm Medium"))))
  #+end_src

- Configure =org-indent= to inherit from =fixed-pitch= to fix the vertical spacing in code blocks. Thanks to Ben for the tip!
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (org-indent ((t (:inherit (org-hide fixed-pitch)))))
  #+end_src

- Configuring the corresponding =org-mode= faces for blocks, verbatim code, and maybe a couple of other things. As these change more frequently, I do them directly from the =customize-face= interface, you can see their current settings in the [[*Customized variables][Customized variables]] section.

- Setting up =visual-line-mode= and making all my paragraphs one single line, so that the lines wrap around nicely in the window according to their proportional-font size, instead of at a fixed character count, which does not work so nicely when characters have varying widths. I set up a hook that automatically enables =visual-line-mode= and =variable-pitch-mode= when entering org-mode.
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
    (org-mode . visual-line-mode)
    (org-mode . variable-pitch-mode)
  #+end_src

- In =variable-pitch= mode, the default right-alignment for headline tags doesn't work, and results in the tags being misaligned (as it uses character positions to do the alignment). This setting positions the tags right after the last character of the headline, so at least they are more consistent.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
    (org-tags-column 0)
  #+end_src

- I also set =org-todo-keyword-faces= to highlight DRAFT items with yellow instead of red.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
    (org-todo-keyword-faces
     '(("TODO" . "red")
       ("DRAFT" . "yellow")
       ("DONE" . "green")
       ("CANCELED" . "blue")))
  #+end_src

  These two modes produce modeline indicators, which I disable using =diminish=.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
    (eval-after-load 'face-remap '(diminish 'buffer-face-mode))
    (eval-after-load 'simple '(diminish 'visual-line-mode))
  #+end_src

** Auto-generated table of contents

The =toc-org= package allows us to insert a table of contents in headings marked with =:TOC:=. This is useful for org files that are to be viewed directly on GitHub, which renders org files correctly, but does not generate a table of contents at the top. For an example, see [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][this file on GitHub]].

Note that this breaks HTML export by default, as the links generated by =toc-org= cannot be parsed properly by the html exporter. The [[https://github.com/snosov1/toc-org/issues/35#issuecomment-275096511][workaround]] is to use =:TOC:noexport:= as the marker, which removed the generated TOC from the export, but still allows =ox-html= to insert its own TOC at the top.

#+begin_src emacs-lisp
  (use-package toc-org
    :after org
    :hook
    (org-mode . toc-org-enable))
#+end_src

** Reformatting an org buffer

I picked up this little gem in the org mailing list. A function that reformats the current buffer by regenerating the text from its internal parsed representation. Quite amazing.

#+begin_src emacs-lisp
  (defun zz/org-reformat-buffer ()
    (interactive)
    (when (y-or-n-p "Really format current buffer? ")
      (let ((document (org-element-interpret-data (org-element-parse-buffer))))
        (erase-buffer)
        (insert document)
        (goto-char (point-min)))))
#+end_src

* Appearance, buffer/file management and theming

Here we take care of all the visual, and UX settings.

We enable ~termguicolors~, which is necessary to use GUI colors inside terminals.

#+BEGIN_SRC vimrc
  if (has("termguicolors"))
    set termguicolors
  endif
#+END_SRC

We also want to set ~syntax~ to ~on~, which makes the editor allow syntax highlighting.

#+BEGIN_SRC vimrc
  syntax on
#+END_SRC

** Theme

Our theme is the bespoke [[https://github.com/Zyst/egoist-one.vim][Zyst/egoist-one.vim]], which is in turn based on [[https://github.com/joshdick/onedark.vim][joshdick/onedark.vim]]. It customizes some elements to my liking.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'Zyst/egoist-one.vim'
#+END_SRC

We proceed to assign our ~colorscheme~ as ~onedark~

#+BEGIN_SRC vimrc
  colorscheme onedark
#+END_SRC

Finally, we set ~g:onedark_terminal_italics~ to ~1~ which enables some of the theme's italics functionality.

#+BEGIN_SRC vimrc
  let g:onedark_terminal_italics=1
#+END_SRC

* Coding

Coding is my primary use for Vim, here's my configuration.

** General settings and modules

With =company-mode=, we get automatic completion - when there are completions available, a popup menu will appear when you stop typing for a moment, and you can either continue typing or accept the completion using the Enter key. I enable it globally.

#+begin_src emacs-lisp
  (use-package company
    :diminish company-mode
    :hook
    (after-init . global-company-mode))
#+end_src

=projectile-mode= allows us to perform project-relative operations such as searches, navigation, etc.

#+begin_src emacs-lisp
  (use-package projectile
    :defer 2
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+end_src

On-the-fly spell checking. I enable it for all text modes.

#+begin_src emacs-lisp
  (use-package flyspell
    :defer 1
    :hook (text-mode . flyspell-mode)
    :diminish
    :bind (:map flyspell-mouse-map
                ([down-mouse-3] . #'flyspell-correct-word)
                ([mouse-3]      . #'undefined)))
#+end_src

** Programming languages

*** Polyglot

Our main language handler is [[https://github.com/sheerun/vim-polyglot][sheerun/vim-polyglot]] which helps us program in a [[https://github.com/sheerun/vim-polyglot#language-packs][variety of languages]] with minimal performance impact, since plugins are loaded on-demand. I'm giving this a try, rather than using individual packages.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'sheerun/vim-polyglot'
#+END_SRC

*** Elvish

[[https://github.com/dmix/elvish.vim][dmix/elvish.vim]] adds limited support for the [[https://github.com/elves/elvish][elvish shell]], essentially limited to syntax highlighting.

#+BEGIN_SRC vimrc :tangle no :noweb-ref plug
  Plug 'dmix/elvish.vim', { 'on_ft': ['elvish']}
#+END_SRC

* Other tools

- [[https://github.com/jschaf/esup][Emacs Startup Profiler]], to get detailed stats of what's taking time during initialization.

  #+begin_src emacs-lisp
    (use-package esup)
  #+end_src

- Macro to measure how long a command takes, from https://stackoverflow.com/questions/23622296/emacs-timing-execution-of-function-calls-in-emacs-lisp

#+begin_src emacs-lisp
  (defmacro measure-time (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))
#+end_src

* General text editing

In addition to coding, I configure some modes that can be used for text editing.

- [[https://daringfireball.net/projects/markdown/syntax][Markdown]], generally useful. I also set up variable pitch and visual line mode.

  #+begin_src emacs-lisp
    (use-package markdown-mode
      :hook
      (markdown-mode . visual-line-mode)
      (markdown-mode . variable-pitch-mode))
  #+end_src

* Epilogue

Here we close the =let= expression from [[*Performance optimization][the preface]].

#+begin_src emacs-lisp
  )
#+end_src

We also reset the value of =gc-cons-threshold=, not to its original value, we still leave it larger than default so that GCs don't happen so often.

#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 2 1000 1000))
#+end_src
