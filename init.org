#+property: header-args:emacs-lisp :tangle (concat (file-name-sans-extension (buffer-file-name)) ".el")
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+begin_src emacs-lisp :exports none
  ;; DO NOT EDIT THIS FILE DIRECTLY
  ;; This is a file generated from a literate programing source file located at
  ;; https://github.com/Zyst/dotfiles/blob/master/init.org
  ;; You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

#+title: My Emacs config file
#+author: Erick Romero

This is my Emacs configuration file.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[file:init.el][init.el]] for the generated file.


* References

This is all Based on [[https://github.com/zzamboni][zzamboni's]] [[https://github.com/zzamboni/dot-emacs][dot-emacs]]. Huge props to them!

* Performance optimization

Lately I've been playing with optimizing my Emacs load time. I have found a couple of useful resources, including:

- [[https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/][Two easy little known steps to speed up Emacs start up time]]
- [[https://blog.d46.us/advanced-emacs-startup/][Advanced Techniques for Reducing Emacs Startup Time]]

Based on these, I have added the code below.

First, a hook that reports how long and how many garbage collections the startup took.

#+begin_src emacs-lisp
  ;; Use a hook so the message doesn't get clobbered by other messages.
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src

Next, we wrap the whole init file in a block that sets =file-name-handler-alist= to =nil= to prevent any special-filename parsing of files loaded from the init file (e.g. remote files loaded through tramp, etc.). The =let= block gets closed in the [[Epilogue][Epilogue]].

#+begin_src emacs-lisp
  (let ((file-name-handler-alist nil))
#+end_src

Optionally enable =debug-on-error= - I do this only when I'm trying to figure out some problem in my config.

#+begin_src emacs-lisp
  ;;(setq debug-on-error t)
#+end_src

We set =gc-cons-threshold= to its maximum value, to prevent any garbage collection from happening during load time. We also reset this value in the [[Epilogue][Epilogue]].

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum)
#+end_src

* Customized variables

Emacs has its own [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html#Easy-Customization][Customization mechanism]] for easily customizing many parameters. To make it easier to manage, I keep the customized variables and faces in a separate file and load it from the main file. A lot of my custom settings are configured from this init file as well, but there are always some which I change by hand for added flexibility.

#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+end_src

Here is the current contents of my [[https://github.com/zzamboni/dot-emacs/blob/master/custom.el][custom.el]] file.

#+include: "~/.emacs.d/custom.el" src emacs-lisp

* Package management

I use the [[https://www.masteringemacs.org/article/spotlight-use-package-a-declarative-configuration-tool][wonderful use-package]] to manage most of the packages in my installation As this is not bundled yet with Emacs, the first thing we do is install it by hand. All other packages are then declaratively installed and configured with =use-package=. This makes it possible to fully bootstrap Emacs using only this config file, everything else is downloaded, installed and configured automatically.

First, we declare the package repositories to use.

#+begin_src emacs-lisp
  (customize-set-variable 'package-archives
                          '(;;("gnu"       . "https://elpa.gnu.org/packages/")
                            ("marmalade" . "https://marmalade-repo.org/packages/")
                            ("melpa"     . "https://melpa.org/packages/")))
#+end_src

Then we initialize the package system, refresh the list of packages and install =use-package= if needed.

#+begin_src emacs-lisp
  (package-initialize)

  (when (not package-archive-contents)
    (package-refresh-contents))

  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))
#+end_src

Finally, we load =use-package=.

#+begin_src emacs-lisp
  (require 'use-package)
#+end_src

We set some configuration for =use-package=:

- The =use-package-always-ensure= variable indicates that =use-package= should always try to install missing packages. For some libraries this is not appropriate, and in those cases you see the =:ensure nil= declaration as part of the =use-package= statement. This applies mainly to libraries which are installed as part of some other package (happens mostly with some libraries that come with org-mode).

  #+begin_src emacs-lisp
    (customize-set-variable 'use-package-always-ensure t)
  #+end_src

- The =use-package-always-defer= sets =:defer true= as the default for all package declarations. This makes Emacs startup much faster by preventing packages from being loaded when Emacs starts, and only doing so when they are needed. Some packages don't work well with this, so you'll see some declarations when I explicitly set =:defer nil= to force the package to be loaded at startup, or =:defer n= to load the package, but only =n= seconds after startup.

  #+begin_src emacs-lisp
    (customize-set-variable 'use-package-always-defer t)
  #+end_src

- The =use-package-verbose= variable enables verbose loading of packages, useful for debugging. I set/unset this according to need.

  #+begin_src emacs-lisp
    (customize-set-variable 'use-package-verbose nil)
  #+end_src

This variable tells Emacs to prefer the =.el= file if it's newer, even if there is a corresponding =.elc= file. Also, use =auto-compile= to autocompile files as needed.

#+begin_src emacs-lisp
  (customize-set-variable 'load-prefer-newer t)
  (use-package auto-compile
    :defer nil
    :config (auto-compile-on-load-mode))
#+end_src

* Settings

** Miscellaneous settings

- Paste text where the cursor is, not where the mouse is.

  #+begin_src emacs-lisp
    (customize-set-variable 'mouse-yank-at-point t)
  #+end_src

- Make completion case-insensitive.

  #+begin_src emacs-lisp
    ;; (setq completion-ignore-case t)
    ;; (customize-set-variable 'read-file-name-completion-ignore-case t)
    ;; (customize-set-variable 'read-buffer-completion-ignore-case t)
  #+end_src

- Show line numbers. I used =linum-mode= before, but it caused severe performance issues on large files. Emacs 26 introduces =display-line-numbers-mode=, which has no perceivable performance impact even on very large files.

  #+begin_src emacs-lisp
    (when (>= emacs-major-version 26)
      (use-package display-line-numbers
        :defer nil
        :ensure nil
        :config
        (global-display-line-numbers-mode)))
  #+end_src

- Highlight trailing whitespace in red, so it's easily visible

  #+begin_src emacs-lisp
    (customize-set-variable 'show-trailing-whitespace t)
  #+end_src

- Highlight matching parenthesis

  #+begin_src emacs-lisp
    (show-paren-mode)
  #+end_src

- Don't use hard tabs

  #+begin_src emacs-lisp
    (customize-set-variable 'indent-tabs-mode nil)
  #+end_src

- Emacs automatically creates backup files, by default in the same folder as the original file, which often leaves backup files behind. This tells Emacs to [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][put all backups in ~/.emacs.d/backups]].

  #+begin_src emacs-lisp
    (customize-set-variable 'backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  #+end_src

- [[http://emacswiki.org/emacs/WinnerMode][WinnerMode]] makes it possible to cycle and undo window configuration changes (i.e. arrangement of panels, etc.)

  #+begin_src emacs-lisp
    (when (fboundp 'winner-mode) (winner-mode))
  #+end_src

- Add "unfill" commands to parallel the "fill" ones, bind ~A-q~ to =unfill-paragraph= and rebind ~M-q~ to the =unfill-toggle= command, which fills/unfills paragraphs alternatively.

  #+begin_src emacs-lisp
    (use-package unfill
      :bind
      ("M-q" . unfill-toggle)
      ("A-q" . unfill-paragraph))
  #+end_src

- Save the place of the cursor in each file, and restore it upon opening it again.

  #+begin_src emacs-lisp
    (use-package saveplace
      :defer nil
      :config
      (save-place-mode))
  #+end_src

- Provide mode-specific "bookmarks" - press =M-i= and you will be presented with a list of elements to which you can navigate - they can be headers in org-mode, function names in emacs-lisp, etc.

  #+begin_src emacs-lisp
    (use-package imenu-anywhere
      :bind
      ("M-i" . helm-imenu-anywhere))
  #+end_src

- Smooth scrolling (line by line) instead of jumping by half-screens.

  #+begin_src emacs-lisp
    (use-package smooth-scrolling
      :config
      (smooth-scrolling-mode 1))
  #+end_src

- Delete trailing whitespace before saving a file.

  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
  #+end_src

- Suppress "ad-handle-definition: .. redefined" warnings during Emacs startup.

  #+begin_src emacs-lisp
    (customize-set-variable 'ad-redefinition-action 'accept)
  #+end_src

* System-specific configuration

Some settings maybe OS-specific, and this is where we set them. For now I only use Emacs on my Mac, so only the Mac section is filled out, but there are sections for Linux and Windows as well.

#+begin_src emacs-lisp :noweb no-export
  (cond ((eq system-type 'darwin)
         <<Mac settings>>
         )
        ((eq system-type 'windows-nt)
         <<Windows settings>>
         )
        ((eq system-type 'gnu/linux)
         <<Linux settings>>
         ))
#+end_src

** Mac
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Mac settings
:END:

There are no Mac-specific settings for now.

** Linux
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Linux settings
:END:

There are no Linux-specific settings for now.

** Windows
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Windows settings
:END:

There are no Windows-specific settings for now.

* Keybindings

I use the =bind-key= package to more easily keep track and manage user keybindings. =bind-key= comes with =use-package= so we just load it.

The main advantage of using this over =define-key= or =global-set-key= is that you can use ~M-x~ =describe-personal-keybindings= to see a list of all the customized keybindings you have defined.

#+begin_src emacs-lisp
  (require 'bind-key)
#+end_src

** Miscellaneous keybindings

- The [[https://github.com/justbur/emacs-which-key][which-key]] package makes Emacs functionality much easier to discover and explore: in short, after you start the input of a command and stop, pondering what key must follow, it will automatically open a non-intrusive buffer at the bottom of the screen offering you suggestions for completing the command, that's it, nothing else. It's beautiful.

  #+begin_src emacs-lisp
    (use-package which-key
      :defer nil
      :diminish which-key-mode
      :config
      (which-key-mode))
  #+end_src

* Evil mode

Make Ctrl-u page up as usual.

#+begin_src emacs-lisp
(setq evil-want-C-u-scroll t)
#+end_src

Initialize evil mode.

#+begin_src emacs-lisp
(require 'evil)
(evil-mode 1)
#+end_src

* Org mode

I have started using [[http://orgmode.org/][org-mode]] to writing, blogging, coding, presentations and more, thanks to the hearty recommendations and information from [[http://www.cmdln.org/][Nick]] and many others. I am duly impressed. I have been a fan of the idea of [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] for many years, and I have tried other tools before (most notably [[https://www.cs.tufts.edu/~nr/noweb/][noweb]], which I used during grad school for many of my homeworks and projects), but org-mode is the first tool I have encountered which seems to make it practical. Here are some of the resources I have found useful in learning it:

- Howard Abrams' [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]], which got me jumpstarted into writing code documented with org-mode.
- Nick Anderson's [[https://github.com/nickanderson/Level-up-your-notes-with-Org][Level up your notes with Org]], which contains many useful tips and configuration tricks.
- Sacha Chua's [[http://sachachua.com/blog/2014/01/tips-learning-org-mode-emacs/][Some tips for learning Org Mode for Emacs]], her [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]] and many of her [[http://sachachua.com/blog/category/emacs/][other articles]].
- Rainer König's [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][OrgMode Tutorial]] video series.

This is the newest and most-in-flux section of my Emacs config, since I'm still learning org-mode myself.

I use =use-package= to load the =org= package, and put its configuration inside the corresponding sections for keybindings (=:bind=), custom variables (=:custom=), custom faces (=:custom-face=), hooks (=:hook=) and general configuration code (=:config=), respectively. The contents of each section is populated with the corresponding snippets that follow. You see here the complete =use-package= declaration for completeness, but see the sections below for the details on where each snippet comes from, and some other configuration code that ends up outside this declaration.

#+begin_src emacs-lisp :noweb yes
  (use-package org
    :bind
      <<org-mode-keybindings>>
    :custom
      <<org-mode-custom-vars>>
    :custom-face
      <<org-mode-faces>>
    :hook
      <<org-mode-hooks>>
    :config
      <<org-mode-config>>)
#+end_src

** General org-mode configuration

Automatically log done times in todo items.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-log-done t)
#+end_src

Keep the indentation well structured by setting =org-startup-indented= to =t=. This is a must have. Makes it feel less like editing a big text file and more like a purpose built editor for org-mode that forces the indentation. Thanks [[https://github.com/nickanderson/Level-up-your-notes-with-Org/blob/master/Level-up-your-notes-with-Org.org#automatic-visual-indention][Nick]] for the tip!

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-startup-indented t)
#+end_src

By default, =org-indent= produces an indicator ="Ind"= in the modeline. We use diminish to hide it.

#+begin_src emacs-lisp
  (use-package org-indent
    :ensure nil
    :diminish)
#+end_src

** Miscellaneous org functions

** Keybindings

** Various exporters

One of the big strengths of org-mode is the ability to export a document in many different formats. Here I load some of the exporters I have found useful.

- Markdown

  #+begin_src emacs-lisp
    (use-package ox-md
      :ensure nil
      :defer 3
      :after org)
  #+end_src

- [[https://help.github.com/categories/writing-on-github/][GitHub Flavored Markdown]]

  #+begin_src emacs-lisp
    (use-package ox-gfm
      :defer 3
      :after org)
  #+end_src

- [[https://github.com/stig/ox-jira.el][Jira markup]]. I also load =org-jira=, which provides a full interface to Jira through org-mode.

  #+begin_src emacs-lisp
    (use-package ox-jira
      :defer 3
      :after org)
    (use-package org-jira
      :defer 3
      :after org
      :custom
      (jiralib-url "https://jira.swisscom.com"))
  #+end_src

- Confluence markup.

  #+begin_src emacs-lisp
    (use-package ox-confluence
      :defer 3
      :ensure nil
      :after org)
  #+end_src

** Literate programming using org-babel

Org-mode is the first literate programming tool that seems practical and useful, since it's easy to edit, execute and document code from within the same tool (Emacs) using all of its existing capabilities (i.e. each code block can be edited in its native Emacs mode, taking full advantage of indentation, completion, etc.)

Plain literate programming is built-in, but the =ob-*= packages provide the ability to execute code in different languages, beyond those included with org-mode.

#+begin_src emacs-lisp
  (use-package ob-elvish
    :after org)
#+end_src

Define =shell-script-mode= as an alias for =console-mode=, so that =console= src blocks can be edited and are fontified correctly.

#+begin_src emacs-lisp
  (defalias 'console-mode 'shell-script-mode)
#+end_src

We configure the languages for which to load org-babel support.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python    . t)
     (shell     . t)
     (elvish    . t)
     (calc      . t)))
#+end_src

This is potentially dangerous: it suppresses the query before executing code from within org-mode. I use it because I am very careful and only press =C-c C-c= on blocks I absolutely understand.

Disabled while I know if I'm actually very careful, lmao.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  ;; (org-confirm-babel-evaluate nil)
#+end_src

This makes it so that code within =src= blocks is fontified according to their corresponding Emacs mode, making the file much more readable.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-src-fontify-natively t)
#+end_src

In principle this makes it so that indentation in =src= blocks works as in their native mode, but in my experience it does not always work reliably. For full proper indentation, always edit the code in a native buffer by pressing =C-c '=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-src-tab-acts-natively t)
#+end_src

Automatically show inline images, useful when executing code that produces them, such as PlantUML or Graphviz.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-babel-after-execute . org-redisplay-inline-images)
#+end_src

This little snippet has revolutionized my literate programming workflow. It automatically runs =org-babel-tangle= upon saving any org-mode buffer, which means the resulting files will be automatically kept up to date.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-mode . (lambda () (add-hook 'after-save-hook 'org-babel-tangle
                                   'run-at-end 'only-in-org-mode)))
#+end_src

I add hooks to measure and report how long the tangling took.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-babel-pre-tangle  . (lambda ()
                             (setq zz/pre-tangle-time (current-time))))
  (org-babel-post-tangle . (lambda ()
                             (message "org-babel-tangle took %s"
                                             (format "%.2f seconds"
                                                     (float-time (time-since zz/pre-tangle-time))))))
#+end_src

** Beautifying org-mode

These settings make org-mode much more readable by using different fonts for headings, hiding some of the markup, etc. This was taken originally from Howard Abrams' [[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html][Org as a Word Processor]], and subsequently tweaked and broken up in the different parts of the =use-package= declaration by me.

First, we set =org-hid-emphasis-markers= so that the markup indicators are not shown.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-hide-emphasis-markers t)
#+end_src

We add an entry to the org-mode font-lock table so that list markers are shown with a middle dot instead of the original character.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

We use the =org-bullets= package to display the titles with nice unicode bullets instead of the text ones.

#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    :hook
    (org-mode . (lambda () (org-bullets-mode 1))))
#+end_src

We choose a nice font for the document title and the section headings. The first one found in the system from the list below is used, and the same font is used for the different levels, in varying sizes.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (let* ((variable-tuple
          (cond ((x-list-fonts   "Roboto")          '(:font   "Roboto"))
                ((x-list-fonts   "Source Sans Pro") '(:font   "Source Sans Pro"))
                ((x-list-fonts   "Lucida Grande")   '(:font   "Lucida Grande"))
                ((x-list-fonts   "Verdana")         '(:font   "Verdana"))
                ((x-family-fonts "Sans Serif")      '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color (face-foreground 'default nil 'default))
         (headline       `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces
     'user
     `(org-level-8        ((t (,@headline ,@variable-tuple))))
     `(org-level-7        ((t (,@headline ,@variable-tuple))))
     `(org-level-6        ((t (,@headline ,@variable-tuple))))
     `(org-level-5        ((t (,@headline ,@variable-tuple))))
     `(org-level-4        ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3        ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2        ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1        ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

I use proportional fonts in org-mode for the text, while keeping fixed-width fonts for blocks, so that source code, tables, etc. are shown correctly. These settings include:

- Setting up the =variable-pitch= face to the proportional font I like to use. I myself use [[https://fonts.google.com/specimen/Roboto][Roboto]]. I'm leaving in the entries from the author who enjoys, [[https://en.wikipedia.org/wiki/Source_Sans_Pro][Source Sans Pro]] and [[https://en.wikipedia.org/wiki/Avenir_(typeface)][Avenir Next]].
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (variable-pitch ((t (:family "Roboto" :height 180 :weight light))))
    ;; (variable-pitch ((t (:family "Source Sans Pro" :height 180 :weight light))))
    ;; (variable-pitch ((t (:family "Avenir Next" :height 180 :weight light))))
  #+end_src

- Setting up the =fixed-pitch= face to be the same as my usual =default= face.
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (fixed-pitch ((t (:family "Operator Mono Medium"))))
  #+end_src

- Configure =org-indent= to inherit from =fixed-pitch= to fix the vertical spacing in code blocks. Thanks to Ben for the tip!
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (org-indent ((t (:inherit (org-hide fixed-pitch)))))
  #+end_src

- Configuring the corresponding =org-mode= faces for blocks, verbatim code, and maybe a couple of other things. As these change more frequently, I do them directly from the =customize-face= interface, you can see their current settings in the [[*Customized variables][Customized variables]] section.

- Setting up =visual-line-mode= and making all my paragraphs one single line, so that the lines wrap around nicely in the window according to their proportional-font size, instead of at a fixed character count, which does not work so nicely when characters have varying widths. I set up a hook that automatically enables =visual-line-mode= and =variable-pitch-mode= when entering org-mode.
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
    (org-mode . visual-line-mode)
    (org-mode . variable-pitch-mode)
  #+end_src

- In =variable-pitch= mode, the default right-alignment for headline tags doesn't work, and results in the tags being misaligned (as it uses character positions to do the alignment). This setting positions the tags right after the last character of the headline, so at least they are more consistent.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
    (org-tags-column 0)
  #+end_src

- I also set =org-todo-keyword-faces= to highlight DRAFT items with yellow instead of red.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
    (org-todo-keyword-faces
     '(("TODO" . "red")
       ("DRAFT" . "yellow")
       ("DONE" . "green")
       ("CANCELED" . "blue")))
  #+end_src

  These two modes produce modeline indicators, which I disable using =diminish=.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
    (eval-after-load 'face-remap '(diminish 'buffer-face-mode))
    (eval-after-load 'simple '(diminish 'visual-line-mode))
  #+end_src

** Auto-generated table of contents

The =toc-org= package allows us to insert a table of contents in headings marked with =:TOC:=. This is useful for org files that are to be viewed directly on GitHub, which renders org files correctly, but does not generate a table of contents at the top. For an example, see [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][this file on GitHub]].

Note that this breaks HTML export by default, as the links generated by =toc-org= cannot be parsed properly by the html exporter. The [[https://github.com/snosov1/toc-org/issues/35#issuecomment-275096511][workaround]] is to use =:TOC:noexport:= as the marker, which removed the generated TOC from the export, but still allows =ox-html= to insert its own TOC at the top.

#+begin_src emacs-lisp
  (use-package toc-org
    :after org
    :hook
    (org-mode . toc-org-enable))
#+end_src

** Reformatting an org buffer

I picked up this little gem in the org mailing list. A function that reformats the current buffer by regenerating the text from its internal parsed representation. Quite amazing.

#+begin_src emacs-lisp
  (defun zz/org-reformat-buffer ()
    (interactive)
    (when (y-or-n-p "Really format current buffer? ")
      (let ((document (org-element-interpret-data (org-element-parse-buffer))))
        (erase-buffer)
        (insert document)
        (goto-char (point-min)))))
#+end_src

* Appearance, buffer/file management and theming

Here we take care of all the visual, UX and desktop-management settings.

You'll notice that many of the packages in this section have =:defer nil=. This is because some of these package are never called explicitly because they operate in the background, but I want them loaded when Emacs starts so they can perform their necessary customization.

Emacs 26 (which I am trying now) introduces pixel-level scrolling.

#+begin_src emacs-lisp
  (when (>= emacs-major-version 26)
    (pixel-scroll-mode))
#+end_src

The =diminish= package makes it possible to remove clutter from the modeline. Here we just load it, it gets enabled for individual packages in their corresponding declarations.

#+begin_src emacs-lisp
  (use-package diminish
    :defer 1)
#+end_src

I have been playing with different themes, and I have settled for now in =gruvbox=. Some of my other favorites are also here so I don't forget about them.

#+begin_src emacs-lisp
  ;;(use-package solarized-theme)
  ;;(use-package darktooth-theme)
  ;;(use-package kaolin-themes)
  (use-package gruvbox-theme)
  (load-theme 'gruvbox)
#+end_src

Install [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] for modeline goodness, including configurable abbreviation of directories, and other things.

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :defer 2
    :config
    (sml/setup)
    :custom
    (sml/theme 'dark)
    (sml/replacer-regexp-list
     '(("^~/\\.emacs\\.d/elpa/"                            ":ELPA:")
       ("^~/\\.emacs\\.d/"                                 ":ED:")
       ("^/sudo:.*:"                                       ":SU:")
       ("^~/Documents/"                                    ":Doc:")
       ("^:\\([^:]*\\):Documento?s/"                       ":\\1/Doc:")
       ("^~/Dropbox/"                                      ":DB:")
       ("^:DB:org"                                         ":Org:")
       ("^:DB:Personal/"                                   ":P:")
       ("^:DB:Personal/writing/"                           ":Write:")
       ("^:P:devel/"                                       ":Dev:")
       ("^:Write:learning-cfengine-3/learning-cfengine-3/" ":cf-learn:")
       ("^:Dev:go/src/github.com/elves/elvish/"            ":elvish:")
       ("^:Dev:zzamboni.org/zzamboni.org/"                 ":zz.org:"))))
#+end_src

Enable desktop-save mode, which saves the current buffer configuration on exit and reloads it on restart.

Desktop mode also includes the =desktop-clear= function, which can be used to kill all open buffers. I bind it to ~Control-Meta-super-k~.

#+begin_src emacs-lisp
  (use-package desktop
    :defer nil
    :custom
    (desktop-restore-eager   1   "Restore only the first buffer right away")
    (desktop-lazy-idle-delay 1   "Restore the rest of the buffers 1 seconds later")
    (desktop-lazy-verbose    nil "Be silent about lazily opening buffers")
    :bind
    ("C-M-s-k" . desktop-clear)
    :config
    (desktop-save-mode))
#+end_src

The =uniquify= package makes it much easier to identify different open files with the same name by prepending/appending their directory or some other information to them. I configure it to add the directory name after the filename. =uniquify= is included with Emacs, so I specify =:ensure nil= so that =use-package= doesn't try to install it, and just loads and configures it.

#+begin_src emacs-lisp
  (use-package uniquify
    :defer 1
    :ensure nil
    :custom
    (uniquify-after-kill-buffer-p t)
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-strip-common-suffix t))
#+end_src

I like to highlight the current line and column. I'm still deciding between two approaches:

- Using the built-in =global-hl-mode= to always highlight the current line, together with the =col-highlight= package, which highlights the column only after a defined interval has passed
- Using the =crosshairs= package, which combines both but always highlights both the column and the line. It also has a "highlight crosshairs when idle" mode, but I prefer to have the current line always highlighted, I'm only undecided about the always-on column highlighting.

Sometimes I find the always-highlighted column to be distracting, but other times I find it useful. So I have both pieces of code here, I'm still deciding. For now only =hl-line= is enabled.

#+begin_src emacs-lisp
  (use-package hl-line
    :defer nil
    :config
    (global-hl-line-mode))
  (use-package col-highlight
    :disabled
    :defer nil
    :config
    (col-highlight-toggle-when-idle)
    (col-highlight-set-interval 2))
  (use-package crosshairs
    :disabled
    :defer nil
    :config
    (crosshairs-mode))
#+end_src

I also use =recentf= to keep a list of recently open buffers. These are visible in helm's open-file mode.

#+begin_src emacs-lisp
  (use-package recentf
    :defer 1
    :custom
    (recentf-max-menu-items 100)
    (recentf-max-saved-items 100)
    :init
    (recentf-mode))
#+end_src

The [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][ibuffer]] package allows all sort of useful operations on the list of open buffers. I haven't customized it yet, but I have a keybinding to open it. (Disabled for now as I am using helm's =helm-buffer-list=).

#+begin_src emacs-lisp
  (use-package ibuffer
    :disabled
    :bind
    ("C-x C-b" . ibuffer))
#+end_src

The [[https://github.com/nonsequitur/smex][smex]] package is incredibly useful, adding IDO integration and some other very nice features to =M-x=, which make it easier to discover and use Emacs commands. Highly recommended. (Disabled for now as I'm using helm's =helm-M-x=).

#+begin_src emacs-lisp
  (use-package smex
    :disabled
    :bind (("M-x" . smex))
    :config (smex-initialize))
#+end_src

[[https://www.emacswiki.org/emacs/MidnightMode][midnight-mode]] purges buffers which haven't been displayed in 3 days. We configure the period so that the cleanup happens every 2 hours (7200 seconds).

#+begin_src emacs-lisp
  (use-package midnight
    :defer 3
    :config
    (setq midnight-period 7200)
    (midnight-mode 1))
#+end_src

For distraction-free writing, I'm testing out =writeroom-mode=.

#+begin_src emacs-lisp
  (use-package writeroom-mode)
#+end_src

[[https://github.com/jaypei/emacs-neotree][NeoTree]] shows a navigation tree on a sidebar, and allows a number of operations on the files and directories. I'm not much of a fan of this type of interface in Emacs, but I have set it up to check it out.

#+begin_src emacs-lisp
  (use-package neotree
    :config
    (customize-set-variable 'neo-theme (if (display-graphic-p) 'icons 'arrow))
    (customize-set-variable 'neo-smart-open t)
    (customize-set-variable 'projectile-switch-project-action 'neotree-projectile-action)
    (defun neotree-project-dir ()
      "Open NeoTree using the git root."
      (interactive)
      (let ((project-dir (projectile-project-root))
            (file-name (buffer-file-name)))
        (neotree-toggle)
        (if project-dir
            (if (neo-global--window-exists-p)
                (progn
                  (neotree-dir project-dir)
                  (neotree-find file-name)))
          (message "Could not find git project root."))))
    :bind
    ([f8] . neotree-project-dir))
#+end_src

=wc-mode= allows counting characters and words, both on demand and continuously. It also allows setting up a word/character goal.

#+begin_src emacs-lisp
  (use-package wc-mode
    :defer 3)
#+end_src

The =all-the-icons= package provides a number of useful icons.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :defer 3)
#+end_src

** Completion: IDO or Helm?

The [[https://tuhdo.github.io/helm-intro.html][battle]] [[https://news.ycombinator.com/item?id=11100312][rages]] [[https://www.reddit.com/r/emacs/comments/3o36sc/what_do_you_prefer_ido_or_helm/][on]] - [[https://github.com/emacs-helm/helm][helm]] or [[https://www.emacswiki.org/emacs/InteractivelyDoThings][IDO]]? Both are nice completion frameworks for Emacs, and both integrate nicely with most main Emacs functions, including file opening, command and buffer selection, etc. I was using IDO for some time but are now giving helm a try. Both my configs are shown below, but only Helm is enabled at the moment.

Should I also look at [[https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/][ivy]]?

*** IDO

I use [[https://www.masteringemacs.org/article/introduction-to-ido-mode][IDO mode]] to get better matching capabilities everywhere in Emacs (disabled while I give helm a try, see below).

#+begin_src emacs-lisp
  (use-package ido
    :disabled
    :config
    (ido-mode t)
    (ido-everywhere 1)
    (setq ido-use-virtual-buffers t)
    (setq ido-enable-flex-matching t)
    (setq ido-use-filename-at-point nil)
    (setq ido-auto-merge-work-directories-length -1))

  (use-package ido-completing-read+
    :disabled
    :config
    (ido-ubiquitous-mode 1))
#+end_src

*** Helm

This config came originally from [[https://github.com/daedreth/UncleDavesEmacs#user-content-ido-and-why-i-started-using-helm][Uncle Dave's Emacs config]], thought I have tweaked it a bit.

#+begin_src emacs-lisp
  (use-package helm
    :defer 1
    :diminish helm-mode
    :bind
    (("C-x C-f"       . helm-find-files)
     ("C-x C-b"       . helm-buffers-list)
     ("C-x b"         . helm-multi-files)
     ("M-x"           . helm-M-x)
     :map helm-find-files-map
     ("C-<backspace>" . helm-find-files-up-one-level)
     ("C-f"           . helm-execute-persistent-action)
     ([tab]           . helm-ff-RET))
    :config
    (defun daedreth/helm-hide-minibuffer ()
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face
                       (let ((bg-color (face-background 'default nil)))
                         `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))
    (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
    (setq helm-autoresize-max-height 0
          helm-autoresize-min-height 40
          helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-split-window-in-side-p nil
          helm-move-to-line-cycle-in-source nil
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-echo-input-in-header-line nil)
    :init
    (helm-mode 1))

  (require 'helm-config)
  (helm-autoresize-mode 1)

  (use-package helm-flx
    :custom
    (helm-flx-for-helm-find-files t)
    (helm-flx-for-helm-locate t)
    :config
    (helm-flx-mode +1))

  (use-package swiper-helm
    :bind
    ("C-s" . swiper))
#+end_src

* Coding

Coding is one of my primary uses for Emacs, although lately it has shifted toward more general writing. This used to be the largest section in my config until [[Org mode][Org mode]] overtook it :)

** General settings and modules

When enabled, =subword= allows navigating "sub words" individually in CamelCaseIdentifiers. For now I only enable it in =clojure-mode=.

#+begin_src emacs-lisp
  (use-package subword
    :hook
    (clojure-mode . subword-mode))
#+end_src

With =aggressive-indent=, indentation is always kept up to date in the whole buffer. Sometimes it gets in the way, but in general it's nice and saves a lot of work, so I enable it for all programming modes except for Python mode, where I explicitly disable as it often gets the indentation wrong and messes up existing code.

Disabled for now while I test how much I miss it (I often find it gets in the way, but I'm not sure how often it helps and I don't even notice it)

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :disabled
    :diminish aggressive-indent-mode
    :hook
    (prog-mode . aggressive-indent-mode)
    (python-mode . (lambda () (aggressive-indent-mode -1))))
#+end_src

With =company-mode=, we get automatic completion - when there are completions available, a popup menu will appear when you stop typing for a moment, and you can either continue typing or accept the completion using the Enter key. I enable it globally.

#+begin_src emacs-lisp
  (use-package company
    :diminish company-mode
    :hook
    (after-init . global-company-mode))
#+end_src

=projectile-mode= allows us to perform project-relative operations such as searches, navigation, etc.

#+begin_src emacs-lisp
  (use-package projectile
    :defer 2
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+end_src

I find =iedit= absolutely indispensable when coding. In short: when you hit =Ctrl-:=, all occurrences of the symbol under the cursor (or the current selection) are highlighted, and any changes you make on one of them will be automatically applied to all others. It's great for renaming variables in code.

#+begin_src emacs-lisp
  (use-package iedit
    :custom
    (iedit-toggle-key-default (kbd "C-;"))
    :config
    (set-face-background 'iedit-occurrence "Magenta"))
#+end_src

Turn on the online documentation mode for all programming modes (not all of them support it) and for the Clojure REPL =cider= mode.

#+begin_src emacs-lisp
  (use-package eldoc
    :diminish
    :hook
    (prog-mode       . turn-on-eldoc-mode)
    (cider-repl-mode . turn-on-eldoc-mode))
#+end_src

On-the-fly spell checking. I enable it for all text modes.

#+begin_src emacs-lisp
  (use-package flyspell
    :defer 1
    :hook (text-mode . flyspell-mode)
    :diminish
    :bind (:map flyspell-mouse-map
                ([down-mouse-3] . #'flyspell-correct-word)
                ([mouse-3]      . #'undefined)))
#+end_src

** Clojure and LISP coding

I dabble in Clojure and Emacs LISP, and Emacs has some fantastic support for them. There's a number of packages and configuration related to this, so I have a whole section for it.

The centerpiece is of course =clojure-mode=. In addition to files ending in =.clj=, I bind it automatically to =.boot= files (both by extension and by [[https://github.com/boot-clj/boot/wiki/For-Emacs-Users][shebang line]]) and to the [[http://riemann.io/][Riemann]] config files.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :mode "\\.clj.*$"
    :mode "riemann.config"
    :mode "\\.boot"
    :config
    (add-to-list 'magic-mode-alist '(".* boot" . clojure-mode)))
#+end_src

Enable some additional fontification for Clojure code.

#+begin_src emacs-lisp
  (use-package clojure-mode-extra-font-locking)
#+end_src

The =cider= package provides a fantastic REPL built into Emacs. We configure a few aspects, including pretty printing, fontification, history size and others.

#+begin_src emacs-lisp
  (use-package cider
    :custom
    ;; nice pretty printing
    (cider-repl-use-pretty-printing nil)
    ;; nicer font lock in REPL
    (cider-repl-use-clojure-font-lock t)
    ;; result prefix for the REPL
    (cider-repl-result-prefix "; => ")
    ;; never ending REPL history
    (cider-repl-wrap-history t)
    ;; looong history
    (cider-repl-history-size 5000)
    ;; persistent history
    (cider-repl-history-file "~/.emacs.d/cider-history")
    ;; error buffer not popping up
    (cider-show-error-buffer nil)
    ;; go right to the REPL buffer when it's finished connecting
    (cider-repl-pop-to-buffer-on-connect t))
#+end_src

We use =clj-refactor= for supporting advanced code refactoring in Clojure.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :config
    (defun my-clojure-mode-hook ()
      (clj-refactor-mode 1)
      (yas-minor-mode 1) ; for adding require/use/import statements
      ;; This choice of keybinding leaves cider-macroexpand-1 unbound
      (cljr-add-keybindings-with-prefix "C-c C-m"))
    :hook
    (clojure-mode . my-clojure-mode-hook))
#+end_src

When coding in LISP-like languages, =rainbow-delimiters= is a must-have - it marks each concentric pair of parenthesis with different colors, which makes it much easier to understand expressions and spot mistakes.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook
    ((prog-mode cider-repl-mode) . rainbow-delimiters-mode))
#+end_src

Another useful addition for LISP coding - =smartparens= enforces parenthesis to match, and adds a number of useful operations for manipulating parenthesized expressions. I map =M-(= to enclose the next expression as in =paredit= using a custom function. Prefix argument can be used to indicate how many expressions to enclose instead of just 1. E.g. =C-u 3 M-(= will enclose the next 3 sexps.

#+begin_src emacs-lisp
    (defun zz/sp-enclose-next-sexp (num) (interactive "p") (insert-parentheses (or num 1)))
    (use-package smartparens
      :diminish smartparens-mode
      :config
      (require 'smartparens-config)
      :custom
      (sp-base-key-bindings 'paredit)
      :hook
      ((clojure-mode
        emacs-lisp-mode
        lisp-mode
        cider-repl-mode
        racket-mode
        racket-repl-mode) . smartparens-strict-mode)
      (smartparens-mode  . sp-use-paredit-bindings)
      (smartparens-mode  . (lambda () (local-set-key (kbd "M-(") 'zz/sp-enclose-next-sexp))))
#+end_src

Minor mode for highlighting the current sexp in LISP modes.

#+begin_src emacs-lisp
  (use-package hl-sexp
    :hook
    ((clojure-mode lisp-mode emacs-lisp-mode) . hl-sexp-mode))
#+end_src

Trying out [[https://github.com/abo-abo/lispy][lispy]] for LISP code editing (disabled for now).

#+begin_src emacs-lisp
  (use-package lispy
    :disabled
    :config
    (defun enable-lispy-mode () (lispy-mode 1))
    :hook
    ((clojure-mode
      emacs-lisp-mode
      common-lisp-mode
      scheme-mode
      lisp-mode) . enable-lispy-mode))
#+end_src

I am sometimes trying out [[https://shaunlebron.github.io/parinfer/][parinfer]] (disabled for now).

#+begin_src emacs-lisp
  (use-package parinfer
    :disabled
    :bind
    (("C-," . parinfer-toggle-mode))
    :init
    (setq parinfer-extensions
          '(defaults       ; should be included.
             pretty-parens  ; different paren styles for different modes.
             ;;evil           ; If you use Evil.
             lispy          ; If you use Lispy. With this extension, you should install Lispy and do not enable lispy-mode directly.
             paredit        ; Introduce some paredit commands.
             smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
             smart-yank))   ; Yank behavior depend on mode.
    :hook
    ((clojure-mode
      emacs-lisp-mode
      common-lisp-mode
      scheme-mode
      lisp-mode) . parinfer-mode))
#+end_src

** Other programming languages

Many other programming languages are well served by a single mode, without so much setup as Clojure/LISP.

- [[http://cfengine.com/][CFEngine]] policy files.

  #+begin_src emacs-lisp
    (use-package cfengine
      :commands cfengine3-mode
      :mode ("\\.cf\\'" . cfengine3-mode))
  #+end_src

- [[https://www.perl.org/][Perl]].

  #+begin_src emacs-lisp
    (use-package cperl-mode
      :mode "\\.p[lm]\\'"
      :interpreter "perl"
      :config
      (setq cperl-hairy t))
  #+end_src

- [[http://fishshell.com/][Fish shell]].

  #+begin_src emacs-lisp
    (use-package fish-mode
      :mode "\\.fish\\'"
      :interpreter "fish")
  #+end_src

- [[https://www.lua.org/][Lua]], which I use for [[http://zzamboni.org/tags/hammerspoon/][Hammerspoon]] configuration.

  #+begin_src emacs-lisp
    (use-package lua-mode)
  #+end_src

- YAML, generally useful

  #+begin_src emacs-lisp
    (use-package yaml-mode)
  #+end_src

- AppleScript

  #+begin_src emacs-lisp
    (use-package applescript-mode)
  #+end_src

- Go

  #+begin_src emacs-lisp
    (use-package go-mode)
  #+end_src

- Build and check MELPA package definitions

  #+begin_src emacs-lisp
    (use-package package-build)
    (use-package package-lint)
  #+end_src

- [[http://elvish.io/][Elvish shell]]

  #+begin_src emacs-lisp
    (use-package elvish-mode)
  #+end_src

- [[https://racket-lang.org/][Racket]]

  #+begin_src emacs-lisp
    (use-package racket-mode)
  #+end_src

- [[https://nixos.org/nix/][Nix]] package files

  #+begin_src emacs-lisp
    (use-package nix-mode)
  #+end_src

* Other tools

- Use =helm-pass= as an interface to =pass=.

  #+begin_src emacs-lisp
    (use-package helm-pass)
  #+end_src

- git interface with some simple configuration I picked up somewhere. When you press ~C-c C-g~, =magit-status= runs full-screen, but when you press ~q~, it restores your previous window setup. Very handy.

  #+begin_src emacs-lisp
    (use-package magit
      :diminish auto-revert-mode
      :bind
      (("C-c C-g" . magit-status)
       :map magit-status-mode-map
       ("q"       . magit-quit-session))
      :config
      (defadvice magit-status (around magit-fullscreen activate)
        "Make magit-status run alone in a frame."
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defun magit-quit-session ()
        "Restore the previous window configuration and kill the magit buffer."
        (interactive)
        (kill-buffer)
        (jump-to-register :magit-fullscreen)))
  #+end_src

- Interface to use the [[https://geoff.greer.fm/ag/][silver-searcher]]

  #+begin_src emacs-lisp
    (use-package ag)
  #+end_src

- Publishing with [[https://gohugo.io/][Hugo]]. I don't use this anymore since I started [[Blogging with Hugo][blogging with ox-hugo]]. I keep it loaded, but without its keybinding, because it makes it easy sometimes to see the history of my Markdown posts.

  #+begin_src emacs-lisp
    (use-package easy-hugo
      :custom
      (easy-hugo-basedir "~/Personal/devel/zzamboni.org/zzamboni.org/")
      (easy-hugo-url "http://zzamboni.org/")
      (easy-hugo-previewtime "300")
      ;;(define-key global-map (kbd "C-c C-e") 'easy-hugo)
      )
  #+end_src

- Function to randomize the order of lines in a region, from https://www.emacswiki.org/emacs/RandomizeBuffer.

  #+begin_src emacs-lisp
    (defun my-randomize-region (beg end)
      "Randomize lines in region from BEG to END."
      (interactive "*r")
      (let ((lines (split-string
                    (delete-and-extract-region beg end) "\n")))
        (when (string-equal "" (car (last lines 1)))
          (setq lines (butlast lines 1)))
        (apply 'insert
               (mapcar 'cdr
                       (sort (mapcar (lambda (x) (cons (random) (concat x "\n"))) lines)
                             (lambda (a b) (< (car a) (car b))))))))
  #+end_src

- [[https://www.gnu.org/software/emacs/manual/html_node/autotype/Autoinserting.html][auto-insert mode]] for automatically inserting user-defined templates for certain file types. It's included with Emacs, so I just configure its directory to one inside my Dropbox, and set the hook to run it automatically when opening a file.

  #+begin_src emacs-lisp
    (use-package autoinsert
      :ensure nil
      :custom
      (auto-insert-directory (concat user-emacs-directory "auto-insert/"))
      :hook
      (find-file . auto-insert))
  #+end_src

- Create and manage [[https://gist.github.com/][GitHub gists]]. Setting =gist-view-gist= to =t= makes it open new gists in the web browser automatically after creating them.

  #+begin_src emacs-lisp
    (use-package gist
      :custom
      (gist-view-gist t "Automatically open new gists in browser"))
  #+end_src

- [[https://github.com/jschaf/esup][Emacs Startup Profiler]], to get detailed stats of what's taking time during initialization.

  #+begin_src emacs-lisp
    (use-package esup)
  #+end_src

- Macro to measure how long a command takes, from https://stackoverflow.com/questions/23622296/emacs-timing-execution-of-function-calls-in-emacs-lisp

#+begin_src emacs-lisp
  (defmacro measure-time (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))
#+end_src

* General text editing

In addition to coding, I configure some modes that can be used for text editing.

- [[https://daringfireball.net/projects/markdown/syntax][Markdown]], generally useful. I also set up variable pitch and visual line mode.

  #+begin_src emacs-lisp
    (use-package markdown-mode
      :hook
      (markdown-mode . visual-line-mode)
      (markdown-mode . variable-pitch-mode))
  #+end_src

* Epilogue

Here we close the =let= expression from [[*Performance optimization][the preface]].

#+begin_src emacs-lisp
  )
#+end_src

We also reset the value of =gc-cons-threshold=, not to its original value, we still leave it larger than default so that GCs don't happen so often.

#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 2 1000 1000))
#+end_src
